
Binderjs的v0.1版本写得算蛮纠结的，洋洋撒撒三百多行代码，团成一团，写完后我也不知道怎么组织成这些代码的，能在这种结构中把功能实现很是靠运气，因为之前把所有的功能实现和细节全部在脑子里面想好，所以写的时候一路写下来，中间就停了两次整理思路。关键是当时还没有接触js的原型继承。现在开始看设计模式，一边开始反思自己以前写的那些库(都已经丢了七七八八了，只是因为binderjs有写了帮助文档，所以现在才能重新起手修改)。

真懂js的人都知道js其实也是面向对象 只是它的继承是基于**原型**来继承，而除了内置函数以外，所有的函数，全部都是一个构造函数。也就是说，js把函数和类的概念完全合并(js的概念是十分先进的，灰常完美的高级语言概念，只是在浏览器上被那些半js工人给黑了……)。

Binderjs v0.1最大的问题莫过于效率和内存开销，因为每一次初始化一个Binder对象，对象的所有方法都会重新初始化一遍，而且因为私有变量是通过闭包实现，内存的释放要直到进程结束才行……这明显很坑。当初写这东西的时候还学jQ的写法，把一堆方法全部都直接传变量给一个Binder函数来实现，js并不支持重构，重构的实现必须通过手动判定传参来实现……好吧这东西的实现并不难，但真心不好维护。

v0.2版本的实现主要的要是实现概念的改进和内存优化上。首先在概念上，不再支持自动类型转换。v0.1版本中每个Binder对象都拥有一套独立丰富的功能，所以通过set方法改变绑定对象时，跟初始化一个对象没什么两样，一样工作得好好的，比如把一个字符串对象转成方法对象，绑定路由照样工作，这其实很没有必要，使用的频率实在不高，而且开销不小(即使通过原型继承也一样，要大量的判断)，所以现在原本的Binder构造器得完全抛弃，换成工厂模式来生产不可转换的对象。只为提高路由效率……同事工厂模式的构造器虽然也搭载了各种对象生产的判定流程，但和原来不一样。原本是 ```Binder(xx,key);```，现在通过配置对象来实现 ```Binder({content:xx,key:keys});```。
另外私有对象还是不能少，和原来一样把所有私有变量和方法全部封装到一个privates对象中，但不同的是访问方式，原本都是通过js神一般的作用域来实现，但很危险，而且现在方法都转化为用原型继承得到，作用域失效，所以是通过传参来实现:

```javascript
var self = this;
self[fn_name]=function(arg){
    publics.prototype[fn_name].apply(self,[privates,arg]):
}
```
(大概的核心实现方法，有兴趣的自行拓展去)
如你所见，privates参数的传递不是用户来操作，而是自动的，因为用户得不到privates，但函数所声明的作用域处却可以，通过apply来把二者联系起来。另外和现代的库一样，提供一个destory来手动销毁公有方法和privates是很有必要的。原型链上的对象是无法直接通过枚举访问得到，所有销毁也是很简单的。

保证了内存的使用效率和安全、绑定路由的执行效率这大概是v0.2的实现。

v0.3还没开始着手写，但现在的思路的实现HTML对象的属性配置以及数组对象的更新(如果有了这个，Binderjs库就完全可以作为mvvm框架中的核心组件了(╯3╰)有点虚，数组对象还真不好说，要保持高效的话……)

**2013-3-28 3:14**