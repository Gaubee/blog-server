代码量已经略大，单单一个文件进行编写700L+的代码，效率实在是不行，尽管结构已经差不多，但是想想在后期维护上的方便，还是放弃了单文件结构，完全使用nodejs来进行开发调试（但是依旧是使用ES3的规则）。

花了大半天配置了自己开发所需的Gruntfile，主要的配置了js的压缩```uglify```，另外为了轻松调试文件模块，文件之间的通信使用了nodejs的required和module['exports']这种方式进行开发，为了兼容客户端的部署，可以使用seajs。

不过为了免去这个麻烦，还是上官网找了相关的插件```clientside```做了配置，总体看起来这个插件的实现方法还是有缺陷的：它是通过将```required(参数)```内的参数解析成相对主文件根目录的文件路径，生成一个对应的```hash```，在不修改源文件的```required```的参数情况下，将参数映射到一个集合中……，细想已经就知道这个插件是针对中小型的库设计的，最重要的就是你的文件名字最好别一样，不然一不小心```required```的参数一样了，而它hash表中只能存一个对应的```module['exports']```，那肯定要出问题。

大型的库（文件结构复杂，很可能出现文名字相同的文件）还是乖乖用[requiredjs]()或者[seajs]()进行部署吧。

重新思考了Binder.js，目前写的东西和我的计划已经相差不远。但有些东西还是略有偏差，比如在设计模式上，在语法规范上……

* 这类对象实在没有必要用new关键字来继承原型,因为为了保护私有集合（包括对象的配置信息、私有方法），在之前Binderjs上就开始使用重新包裹函数，将私有集合改成自动传入，实现方法：

```javascript
function _WrapFunctionFactory(mainFn,privateInstances){
    // console.log(item);
    return function(){
        var
            args = [].concat(privateInstances),
            self = this
            ;
        args = args.concat([].slice.call(arguments));
        return mainFn.apply(self,args);
    };
}
```
所以继承原型的那些方法反倒是一种浪费资源的行为。
另外不得不说的是这种方法的缺陷是明显的，如你所见——闭包！说到闭包就会让人联想到内存泄露。
不过克服方法还是有的，就是显示地Destroy这些动态生成的方法。

**2013/4/19 16:54:18**